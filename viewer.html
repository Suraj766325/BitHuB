<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>PDF Viewer</title>

  <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf_viewer.min.css"/>

  <style>
    body{margin:0;font-family:Arial,Helvetica,sans-serif;background:#222;color:#eee;overflow-y:scroll}
    .toolbar{display:flex;gap:8px;align-items:center;padding:8px;background:#111;position:sticky;top:0;z-index:10}
    button{background:#333;color:#fff;border:1px solid #444;padding:6px 10px;border-radius:4px;cursor:pointer}
    button:active{transform:translateY(1px)}
    #canvasContainer{display:flex;justify-content:center;padding:16px}
    #pagesContainer{width:100%;max-width:1200px}
    .page-wrapper{position:relative;display:flex;justify-content:center;margin:12px 0}
    canvas{box-shadow:0 10px 30px rgba(0,0,0,0.7);background:#fff}
    .textLayer{position:absolute;left:0;top:0;right:0;bottom:0;overflow:hidden;opacity:0.25}
    .spacer{flex:1}
    input[type="text"]{background:#222;border:1px solid #444;color:#fff;padding:6px;border-radius:4px;width:160px}
    #loader{position:fixed;inset:0;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,0.6);z-index:9999;color:#fff;font-size:18px}
  </style>
</head>
<body>

<div class="toolbar">
  <button id="prev">Prev</button>
  <button id="next">Next</button>

  <span>Page <span id="pageNum">0</span> / <span id="pageCount">0</span></span>

  <div class="spacer"></div>

  <input id="searchBox" type="text" placeholder="Search text..." />
  <button id="searchBtn">Find</button>

  <button id="zoomOut">-</button>
  <button id="zoomIn">+</button>
</div>

<div id="canvasContainer">
  <div id="pagesContainer"></div>
</div>

<div id="loader" style="display:none">
  Loading PDF... <span id="percent">0%</span>
</div>

<script>
function loadPdfJs() {
  return new Promise((resolve, reject) => {
    if (window.pdfjsLib) return resolve();

    const s1 = document.createElement('script');
    s1.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.min.js';

    s1.onload = () => {
      const s2 = document.createElement('script');
      s2.src = 'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf_viewer.min.js';
      s2.onload = resolve;
      s2.onerror = () => reject(new Error('viewer failed'));
      document.head.appendChild(s2);
    };

    s1.onerror = () => reject(new Error('pdf.js failed'));
    document.head.appendChild(s1);
  });
}

const urlParams = new URLSearchParams(window.location.search);
const file = urlParams.get('file');

if (!file) {
  document.body.innerHTML = '<div style="padding:20px;color:#f88">No file provided.</div>';
  throw new Error('No file');
}

(async function init() {

  await loadPdfJs();

  pdfjsLib.GlobalWorkerOptions.workerSrc =
    'https://cdnjs.cloudflare.com/ajax/libs/pdf.js/2.16.105/pdf.worker.min.js';

  const pagesContainer = document.getElementById('pagesContainer');

  let pdfDoc = null;
  let scale = 1;
  let currentVisiblePage = 1;
  const rendered = new Set();

  const pageNumElem = document.getElementById('pageNum');
  const pageCountElem = document.getElementById('pageCount');
  const loader = document.getElementById('loader');
  const percent = document.getElementById('percent');

  async function fetchArrayBufferWithProgress(url) {
    loader.style.display = 'flex';
    percent.textContent = '0%';

    const resp = await fetch(url);
    if (!resp.ok) throw new Error('Network error');

    const reader = resp.body.getReader();
    const contentLength = resp.headers.get('content-length');

    let received = 0;
    const chunks = [];

    while (true) {
      const {done, value} = await reader.read();
      if (done) break;

      chunks.push(value);
      received += value.length;

      if (contentLength) {
        percent.textContent =
          Math.round((received / contentLength) * 100) + '%';
      }
    }

    loader.style.display = 'none';

    const ab = new Uint8Array(received);
    let offset = 0;

    for (const chunk of chunks) {
      ab.set(chunk, offset);
      offset += chunk.length;
    }

    return ab.buffer;
  }

  function makePageCanvas(pageNumber) {

    const wrapper = document.createElement('div');
    wrapper.className = 'page-wrapper';

    const canvas = document.createElement('canvas');
    canvas.dataset.page = pageNumber;

    const textLayer = document.createElement('div');
    textLayer.className = 'textLayer';

    wrapper.appendChild(canvas);
    wrapper.appendChild(textLayer);

    return {wrapper, canvas, textLayer};
  }

  async function renderPageToCanvas(num, canvas, textLayerDiv) {

    const page = await pdfDoc.getPage(num);
    const viewport = page.getViewport({scale});

    canvas.height = viewport.height;
    canvas.width = viewport.width;

    canvas.style.height = viewport.height + 'px';
    canvas.style.width = viewport.width + 'px';

    textLayerDiv.style.height = viewport.height + 'px';
    textLayerDiv.style.width = viewport.width + 'px';

    await page.render({
      canvasContext: canvas.getContext('2d'),
      viewport
    }).promise;

    const textContent = await page.getTextContent();

    pdfjsLib.renderTextLayer({
      textContent,
      container: textLayerDiv,
      viewport,
      textDivs: []
    });

    pageNumElem.textContent = currentVisiblePage;
  }

  const arrayBuffer = await fetchArrayBufferWithProgress(file);

  pdfDoc = await pdfjsLib.getDocument({
    data: arrayBuffer,
    enableXfa: false
  }).promise;

  pageCountElem.textContent = pdfDoc.numPages;

  for (let i = 1; i <= pdfDoc.numPages; i++) {
    const {wrapper, canvas, textLayer} = makePageCanvas(i);

    canvas.dataset.textLayerId = i;
    wrapper.dataset.page = i;

    pagesContainer.appendChild(wrapper);
  }

  const firstPage = await pdfDoc.getPage(1);
  const viewport1 = firstPage.getViewport({scale:1});

  const containerWidth =
    Math.max(300, pagesContainer.clientWidth * 0.95);

  scale = containerWidth / viewport1.width;

  const observer = new IntersectionObserver(async entries => {

    for (const entry of entries) {

      if (!entry.isIntersecting) continue;

      const wrapper = entry.target;
      const page = Number(wrapper.dataset.page);

      currentVisiblePage = page;
      pageNumElem.textContent = page;

      if (rendered.has(page)) continue;

      rendered.add(page);

      const canvas = wrapper.querySelector('canvas');
      const textLayer = wrapper.querySelector('.textLayer');

      renderPageToCanvas(page, canvas, textLayer);
    }

  }, {threshold:0.2});

  document
    .querySelectorAll('.page-wrapper')
    .forEach(w => observer.observe(w));

  async function rerenderVisiblePages() {

    const wrappers =
      document.querySelectorAll('.page-wrapper');

    wrappers.forEach(wrapper => {

      const page = Number(wrapper.dataset.page);

      if (!rendered.has(page)) return;

      const canvas = wrapper.querySelector('canvas');
      const textLayer = wrapper.querySelector('.textLayer');

      canvas.getContext('2d')
            .clearRect(0,0,canvas.width,canvas.height);

      textLayer.innerHTML = '';

      renderPageToCanvas(page, canvas, textLayer);
    });
  }

  document.getElementById('zoomIn')
    .addEventListener('click', () => {
      scale = Math.min(scale + 0.1, 4);
      rerenderVisiblePages();
    });

  document.getElementById('zoomOut')
    .addEventListener('click', () => {
      scale = Math.max(scale - 0.1, 0.25);
      rerenderVisiblePages();
    });

  let lastDistance = null;

  document.addEventListener('touchmove', e => {

    if (e.touches.length !== 2) {
      lastDistance = null;
      return;
    }

    const dx =
      e.touches[0].clientX -
      e.touches[1].clientX;

    const dy =
      e.touches[0].clientY -
      e.touches[1].clientY;

    const distance = Math.sqrt(dxdx + dydy);

    if (lastDistance) {

      if (distance > lastDistance) {
        scale = Math.min(scale + 0.02, 4);
      } else {
        scale = Math.max(scale - 0.02, 0.25);
      }

      rerenderVisiblePages();
    }

    lastDistance = distance;

  }, {passive:true});

  document.getElementById('searchBtn')
    .addEventListener('click', async () => {

      const query =
        document.getElementById('searchBox')
                .value
                .toLowerCase()
                .trim();

      if (!query) return;

      for (let i = 1; i <= pdfDoc.numPages; i++) {

        const page = await pdfDoc.getPage(i);
        const text = await page.getTextContent();

        const combined =
          text.items.map(t => t.str.toLowerCase()).join(' ');

        if (combined.includes(query)) {

          const el =
            document.querySelector('[data-page="'+i+'"]');

          el.scrollIntoView({behavior:'smooth'});

          return;
        }
      }

      alert('Text not found.');
    });

  document.getElementById('prev')
    .addEventListener('click', () => {

      const target =
        Math.max(1, currentVisiblePage - 1);

      document
        .querySelector('[data-page="'+target+'"]')
        ?.scrollIntoView({behavior:'smooth'});
    });

  document.getElementById('next')
    .addEventListener('click', () => {

      const target =
        Math.min(pdfDoc.numPages,
                 currentVisiblePage + 1);

      document
        .querySelector('[data-page="'+target+'"]')
        ?.scrollIntoView({behavior:'smooth'});
    });

  window.addEventListener('resize', async () => {

    const viewport1 =
      (await pdfDoc.getPage(1))
        .getViewport({scale:1});

    const containerWidth =
      Math.max(300, pagesContainer.clientWidth * 0.95);

    scale = containerWidth / viewport1.width;

    rerenderVisiblePages();
  });

  document.addEventListener('contextmenu', e => e.preventDefault());

})();
</script>
</body>
</html>